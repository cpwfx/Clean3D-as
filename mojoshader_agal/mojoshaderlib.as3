// This file was automatically generated by SWIG (http://www.swig.org).
// Version 2.0.4
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.

/* Function pointers support */
package com.adobe.flascc.swig {
import flash.utils.Dictionary;
import com.adobe.flascc.CModule;

[Weak]
var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
[Weak]
var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
[Weak]
var _SWIG_AS3FreeFuncPtrs:Array = new Array();

[Weak]
public function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
    if (_SWIG_AS3Ptr2Func[ptr]) {
        throw("tried to register AS-callable wrapper for existing AS wrapper");
    }
    _SWIG_AS3Func2Ptr[wrapper] = ptr;
    _SWIG_AS3Ptr2Func[ptr] = wrapper;
}

[Weak]
public function SWIG_AS3UnregASCallWrapper(wrapper:Function):void {
    var ptr:int = _SWIG_AS3Func2Ptr[wrapper];
    delete _SWIG_AS3Func2Ptr[wrapper];
    delete _SWIG_AS3Ptr2Func[ptr];
}

// Returns Function objects callable from AS
[Weak]
public function SWIG_AS3GetASCallWrapper(ptr:int):Function {
    if (_SWIG_AS3Ptr2Func[ptr]) {
        return _SWIG_AS3Ptr2Func[ptr];
    } else {
        return null;
    }
}

// Returns the number of wrapped C and AS functions
[Weak]
public function SWIG_AS3WrapperNum():uint {
    var num:uint = 0;
    for (var key:int in _SWIG_AS3Ptr2Func) {
        num++;
    }
    return num;
}

[Weak]
public function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
    var ptr:int;
    
    if (_SWIG_AS3Func2Ptr[func]) {
        throw("tried to register C-callable wrapper for native C function");
    }

    if (_SWIG_AS3FreeFuncPtrs.length) {
        ptr = _SWIG_AS3FreeFuncPtrs.pop();
    } else {
        ptr = CModule.allocFunPtrs(null, 1, 4);
    }
    CModule.regFun(ptr, wrapper);
    _SWIG_AS3Func2Ptr[func] = ptr;
    _SWIG_AS3Ptr2Func[ptr] = func;

}

[Weak]
public function SWIG_AS3UnregCCallWrapper(func:Function):void {
    var ptr:int = _SWIG_AS3Func2Ptr[func];
    delete _SWIG_AS3Func2Ptr[func];
    delete _SWIG_AS3Ptr2Func[ptr];
    _SWIG_AS3FreeFuncPtrs.push(ptr);
}

// Returns a C function pointer corresponding to an Actionscript-callable 
// wrapper Function. (The C function is callable from C, of course).
[Weak]
public function SWIG_AS3GetCCallPtr(func:Function):int {
    if (_SWIG_AS3Func2Ptr[func]) {
        return _SWIG_AS3Func2Ptr[func];
    } else {
        return 0;
    }
}
} /* package */


package {
import C_Run.*;
import com.adobe.flascc.swig.*;
import flash.utils.ByteArray;

public class Preprocess_errorValue {
	public static const size:int = 20;

	private const _ba:ByteArray;
	private const _offs:int;

	public function Preprocess_errorValue(ba:ByteArray = null, offs:int = 0) {
		if (!ba) {
			ba = new ByteArray();
			ba.endian = "littleEndian";
			ba.length = 20;
		}
		_ba = ba;
		_offs = offs;
	}

	public function addressOf():int {
		import C_Run.ram;
		if (_ba != ram) {
			throw new Error("Cannot take address of object not in domainMemory");
		}
		return _offs;
	}

	public function get error():int {
		_ba.position = _offs + 0;
		return _ba.readInt();
	}

	public function set error(v:int):void {
		_ba.position = _offs + 0;
		_ba.writeInt(v);
	}

	public function get errorlen():uint {
		_ba.position = _offs + 4;
		return _ba.readUnsignedInt();
	}

	public function set errorlen(v:uint):void {
		_ba.position = _offs + 4;
		_ba.writeInt(v);
	}

	public function get filename():int {
		_ba.position = _offs + 8;
		return _ba.readInt();
	}

	public function set filename(v:int):void {
		_ba.position = _offs + 8;
		_ba.writeInt(v);
	}

	public function get filenamelen():uint {
		_ba.position = _offs + 12;
		return _ba.readUnsignedInt();
	}

	public function set filenamelen(v:uint):void {
		_ba.position = _offs + 12;
		_ba.writeInt(v);
	}

	public function get error_position():int {
		_ba.position = _offs + 16;
		return _ba.readInt();
	}

	public function set error_position(v:int):void {
		_ba.position = _offs + 16;
		_ba.writeInt(v);
	}

	public function read(ptr:int):void {
		import C_Run.ram;
		_ba.position = _offs;
		_ba.readBytes(ram, ptr, size);
	}

	public function write(ptr:int, ba:ByteArray = null):void {
		import C_Run.ram;
		if (!ba) {
			ba = C_Run.ram;
		}
		ba.position = ptr;
		ba.writeBytes(_ba, _offs, size);
	}
}

public class Preprocess_dataValue {
	public static const size:int = 16;

	private const _ba:ByteArray;
	private const _offs:int;

	public function Preprocess_dataValue(ba:ByteArray = null, offs:int = 0) {
		if (!ba) {
			ba = new ByteArray();
			ba.endian = "littleEndian";
			ba.length = 16;
		}
		_ba = ba;
		_offs = offs;
	}

	public function addressOf():int {
		import C_Run.ram;
		if (_ba != ram) {
			throw new Error("Cannot take address of object not in domainMemory");
		}
		return _offs;
	}

	public function get error_count():int {
		_ba.position = _offs + 0;
		return _ba.readInt();
	}

	public function set error_count(v:int):void {
		_ba.position = _offs + 0;
		_ba.writeInt(v);
	}

	public function get errors():int {
		_ba.position = _offs + 4;
		return _ba.readInt();
	}

	public function set errors(v:int):void {
		_ba.position = _offs + 4;
		_ba.writeInt(v);
	}

	public function get output():int {
		_ba.position = _offs + 8;
		return _ba.readInt();
	}

	public function set output(v:int):void {
		_ba.position = _offs + 8;
		_ba.writeInt(v);
	}

	public function get outputlen():uint {
		_ba.position = _offs + 12;
		return _ba.readUnsignedInt();
	}

	public function set outputlen(v:uint):void {
		_ba.position = _offs + 12;
		_ba.writeInt(v);
	}

	public function read(ptr:int):void {
		import C_Run.ram;
		_ba.position = _offs;
		_ba.readBytes(ram, ptr, size);
	}

	public function write(ptr:int, ba:ByteArray = null):void {
		import C_Run.ram;
		if (!ba) {
			ba = C_Run.ram;
		}
		ba.position = ptr;
		ba.writeBytes(_ba, _offs, size);
	}
}

public class Preprocess_defineValue {
	public static const size:int = 8;

	private const _ba:ByteArray;
	private const _offs:int;

	public function Preprocess_defineValue(ba:ByteArray = null, offs:int = 0) {
		if (!ba) {
			ba = new ByteArray();
			ba.endian = "littleEndian";
			ba.length = 8;
		}
		_ba = ba;
		_offs = offs;
	}

	public function addressOf():int {
		import C_Run.ram;
		if (_ba != ram) {
			throw new Error("Cannot take address of object not in domainMemory");
		}
		return _offs;
	}

	public function get identifier():int {
		_ba.position = _offs + 0;
		return _ba.readInt();
	}

	public function set identifier(v:int):void {
		_ba.position = _offs + 0;
		_ba.writeInt(v);
	}

	public function get definition():int {
		_ba.position = _offs + 4;
		return _ba.readInt();
	}

	public function set definition(v:int):void {
		_ba.position = _offs + 4;
		_ba.writeInt(v);
	}

	public function read(ptr:int):void {
		import C_Run.ram;
		_ba.position = _offs;
		_ba.readBytes(ram, ptr, size);
	}

	public function write(ptr:int, ba:ByteArray = null):void {
		import C_Run.ram;
		if (!ba) {
			ba = C_Run.ram;
		}
		ba.position = ptr;
		ba.writeBytes(_ba, _offs, size);
	}
}

public class mojoshaderlib {
	public static function preprocess(filename:String, source:String, sourcelen:int, defines:int, define_count:int, onIncludeOpen:Function):int {
		return _wrap_preprocess(filename, source, sourcelen, defines, define_count, onIncludeOpen);
	}

	public static function freePreprocessData(data:int):void {
		_wrap_freePreprocessData(data);
	}

}
} /* package */
