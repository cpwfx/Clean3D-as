// This file was automatically generated by SWIG (http://www.swig.org).
// Version 2.0.4
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.

/* Function pointers support */
package com.adobe.flascc.swig {
import flash.utils.Dictionary;
import com.adobe.flascc.CModule;

[Weak]
var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
[Weak]
var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
[Weak]
var _SWIG_AS3FreeFuncPtrs:Array = new Array();

[Weak]
public function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
    if (_SWIG_AS3Ptr2Func[ptr]) {
        throw("tried to register AS-callable wrapper for existing AS wrapper");
    }
    _SWIG_AS3Func2Ptr[wrapper] = ptr;
    _SWIG_AS3Ptr2Func[ptr] = wrapper;
}

[Weak]
public function SWIG_AS3UnregASCallWrapper(wrapper:Function):void {
    var ptr:int = _SWIG_AS3Func2Ptr[wrapper];
    delete _SWIG_AS3Func2Ptr[wrapper];
    delete _SWIG_AS3Ptr2Func[ptr];
}

// Returns Function objects callable from AS
[Weak]
public function SWIG_AS3GetASCallWrapper(ptr:int):Function {
    if (_SWIG_AS3Ptr2Func[ptr]) {
        return _SWIG_AS3Ptr2Func[ptr];
    } else {
        return null;
    }
}

// Returns the number of wrapped C and AS functions
[Weak]
public function SWIG_AS3WrapperNum():uint {
    var num:uint = 0;
    for (var key:int in _SWIG_AS3Ptr2Func) {
        num++;
    }
    return num;
}

[Weak]
public function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
    var ptr:int;
    
    if (_SWIG_AS3Func2Ptr[func]) {
        throw("tried to register C-callable wrapper for native C function");
    }

    if (_SWIG_AS3FreeFuncPtrs.length) {
        ptr = _SWIG_AS3FreeFuncPtrs.pop();
    } else {
        ptr = CModule.allocFunPtrs(null, 1, 4);
    }
    CModule.regFun(ptr, wrapper);
    _SWIG_AS3Func2Ptr[func] = ptr;
    _SWIG_AS3Ptr2Func[ptr] = func;

}

[Weak]
public function SWIG_AS3UnregCCallWrapper(func:Function):void {
    var ptr:int = _SWIG_AS3Func2Ptr[func];
    delete _SWIG_AS3Func2Ptr[func];
    delete _SWIG_AS3Ptr2Func[ptr];
    _SWIG_AS3FreeFuncPtrs.push(ptr);
}

// Returns a C function pointer corresponding to an Actionscript-callable 
// wrapper Function. (The C function is callable from C, of course).
[Weak]
public function SWIG_AS3GetCCallPtr(func:Function):int {
    if (_SWIG_AS3Func2Ptr[func]) {
        return _SWIG_AS3Func2Ptr[func];
    } else {
        return 0;
    }
}
} /* package */


package {
import C_Run.*;
import com.adobe.flascc.swig.*;
import flash.utils.ByteArray;

public class Flash3dLib {
	public static function get MAX_JOINTS():int{
		return _wrap_MAX_JOINTS();
	}

	public static function get JOINT_POSE_LEN():int{
		return _wrap_JOINT_POSE_LEN();
	}

	public static function get JOINT_BIND_LEN():int{
		return _wrap_JOINT_BIND_LEN();
	}

	public static function get WORLD_MATRICES_LEN():int{
		return _wrap_WORLD_MATRICES_LEN();
	}

	public static function get BLEND_WEIGHTS():Number{
		return _wrap_BLEND_WEIGHTS();
	}

	public static function get PARTICLE_JOINT_LEN():int{
		return _wrap_PARTICLE_JOINT_LEN();
	}

	public static function get MAX_JOINT_PARTICLES():int{
		return _wrap_MAX_JOINT_PARTICLES();
	}

	public static function get VEC3_LEN():int{
		return _wrap_VEC3_LEN();
	}

	public static function get MATRIX_LEN():int{
		return _wrap_MATRIX_LEN();
	}

	public static function get BIND_PARAM_LEN():int{
		return _wrap_BIND_PARAM_LEN();
	}

	public static function get BIND_RESULT_LEN():int{
		return _wrap_BIND_RESULT_LEN();
	}

	public static function get BIND_COUNT_MAX():int{
		return _wrap_BIND_COUNT_MAX();
	}

	public static function examineBytes(buffer:int, bufferSize:int):int {
		return _wrap_examineBytes(buffer, bufferSize);
	}

	public static function poseLocalToWorld(localPose:int, worldPose:int, parentIndices:int, numJoints:int):void {
		_wrap_poseLocalToWorld(localPose, worldPose, parentIndices, numJoints);
	}

	public static function updateGlobalProperties(worldPose:int, inverseBindPose:int, globalMatrices:int, numJoints:int, useDualQuat:int):void {
		_wrap_updateGlobalProperties(worldPose, inverseBindPose, globalMatrices, numJoints, useDualQuat);
	}

	public static function differencePose(currentPose:int, nextPose:int, targetPose:int, numJoints:int, blendWeight:Number, highQuality:int):void {
		_wrap_differencePose(currentPose, nextPose, targetPose, numJoints, blendWeight, highQuality);
	}

	public static function slerpPose(currentPose:int, nextPose:int, targetPose:int, numJoints:int, blendWeight:Number, highQuality:int):void {
		_wrap_slerpPose(currentPose, nextPose, targetPose, numJoints, blendWeight, highQuality);
	}

	public static function transformVector(jointPose:int, position:int, target:int):void {
		_wrap_transformVector(jointPose, position, target);
	}

	public static function jointPoseToMatrix(jointPose:int, mat:int):void {
		_wrap_jointPoseToMatrix(jointPose, mat);
	}

	public static function transformVectors(pose:int, particleJoints:int, numParticles:int, dv:int):void {
		_wrap_transformVectors(pose, particleJoints, numParticles, dv);
	}

	public static function generateDifferencePose(sourcePose:int, reference:int, differencePose:int, numJoints:int):void {
		_wrap_generateDifferencePose(sourcePose, reference, differencePose, numJoints);
	}

	public static function updateJointsBindInfo(pose:int, bindParams:int, bindResults:int, bindCount:int):void {
		_wrap_updateJointsBindInfo(pose, bindParams, bindResults, bindCount);
	}

	public static function getParticleJointSize():int {
		return _wrap_getParticleJointSize();
	}

	public static function updatePoseMatricesAndSkinDatas(jointPoseMatrices:int, jointSkinDatas:int, animationPoses:int, parentIndices:int, inverseBindPose:int, frame:int, numJoints:int, useDualQuat:int):void {
		_wrap_updatePoseMatricesAndSkinDatas(jointPoseMatrices, jointSkinDatas, animationPoses, parentIndices, inverseBindPose, frame, numJoints, useDualQuat);
	}

	public static function getCondensedSkinDatas(condensedSkinDatas:int, jointSkinDatas:int, jointsMap:int, numJointsMap:int, useDualQuat:int):void {
		_wrap_getCondensedSkinDatas(condensedSkinDatas, jointSkinDatas, jointsMap, numJointsMap, useDualQuat);
	}

	public static function getCondensedPoseMatrices(condensedPoseMatrices:int, jointPoseMatrices:int, jointsMap:int, numJointsMap:int):void {
		_wrap_getCondensedPoseMatrices(condensedPoseMatrices, jointPoseMatrices, jointsMap, numJointsMap);
	}

	public static function copyFrame(dst_matrices:int, dst_poses:int, src_matrices:int, src_poses:int, matricesLen:int, posesLen:int):void {
		_wrap_copyFrame(dst_matrices, dst_poses, src_matrices, src_poses, matricesLen, posesLen);
	}

}
} /* package */
